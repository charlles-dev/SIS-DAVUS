# **3\. Frontend Architecture & Component Guide**

Stack: React 18, Vite, TypeScript, Tailwind CSS, Shadcn/UI, React Query, Zustand.  
Hospedagem: Vercel (Free).

## **1\. Gerenciamento de Estado & Cache (Crucial para Free Tier)**

Como o Backend pode ser lento, o Frontend assume a responsabilidade de parecer rápido ("Optimistic UI").

### **1.1. React Query Config (src/lib/queryClient.ts)**

import { QueryClient } from '@tanstack/react-query';

export const queryClient \= new QueryClient({  
  defaultOptions: {  
    queries: {  
      retry: 2,  
      staleTime: 1000 \* 60 \* 5, // 5 minutos. Dados não expiram rápido.  
      gcTime: 1000 \* 60 \* 30, // 30 min em cache (garbage collection).  
      refetchOnWindowFocus: false, // Evita refetch agressivo e cold starts desnecessários.  
    },  
  },  
});

### **1.2. Stores Globais (Zustand)**

* useAuthStore: Persistido no localStorage. Armazena JWT e User Profile.  
* useCartStore: Carrinho de movimentações. Permite ao almoxarife adicionar 20 itens offline e enviar um "Batch Checkout" quando a conexão voltar.

## **2\. Componentes de Performance**

### **2.1. ServerAwakeGuard.tsx**

Um componente wrapper que detecta latência.

* **Lógica:** Intercepta requests. Se pending \> 2s, exibe Toast: *"Conectando ao servidor seguro..."*. Se \> 10s: *"Servidor em wake-up, aguarde..."*.  
* **UX:** Evita que o usuário ache que o app travou.

### **2.2. ImageCompressor.ts**

Utilitário obrigatório antes de qualquer POST de imagem.

* **Lib:** browser-image-compression.  
* **Config:**  
  const options \= {  
    maxSizeMB: 0.5, // Máximo 500KB  
    maxWidthOrHeight: 1280,  
    useWebWorker: true,  
    fileType: 'image/webp' // Força WebP  
  }

## **3\. Estrutura de Diretórios Otimizada**

/src  
  /api          \# Definições de endpoints (Axios)  
  /assets       \# SVGs leves  
  /components  
    /feedback   \# Loaders, Skeletons (Crucial para cold start)  
    /form       \# Inputs com debounce (Evita spam de requests)  
  /hooks  
    useServerStatus.ts \# Hook de verificação de saúde da API  
  /lib  
    supabase.ts \# Cliente (apenas se formos ler storage direto)

## **4\. Service Worker (PWA)**

Configurar vite-plugin-pwa:

* Cache de fontes, CSS e JS.  
* Cache de GET /api/v1/inventory/products/ (stale-while-revalidate) para permitir consulta de catálogo mesmo sem internet momentânea.

---

## **5\. Melhorias de UX/UI (Dez/2025)**

1. Acessibilidade
   * Adição de `aria-*` e associação `label -> input` em `Button`, `Input`, `Select` (src/components/UI.tsx:117, 167, 195).
   * `Dialog` com `role="dialog"`, `aria-modal` e `aria-labelledby` (src/components/UI.tsx:254).
   * Navegação com `aria-label`, `aria-current` e controle de colapso/expansão no Sidebar (src/components/Sidebar.tsx:59, 85, 146).
   * BottomNav com `role="menubar"` e itens `role="menuitem"` (src/components/BottomNav.tsx:120, 153).

2. PWA & Offline
   * `navigateFallback: offline.html` e runtime caching para API e Storage do Supabase (vite.config.ts:63-95).
   * Metadados PWA e preconnect para Google Fonts em `index.html`.

3. Performance
   * `preconnect` e `crossorigin` para fontes; `loading="lazy"` em `DavusLogo` (src/components/UI.tsx:11).
   * Safe area para iOS no BottomNav (`.pb-safe` em src/index.css:...).

6. Fluxo de Carregamento de Dados & Diagnóstico
   * Credenciais: ler `VITE_SUPABASE_URL` e `VITE_SUPABASE_ANON_KEY` via `import.meta.env` (src/lib/supabase.ts).
   * Conexão: `DiagnosticsService.ping()` valida acesso e retorna feedback (src/api/services.ts:690).
   * Timeout: chamadas críticas usam `withTimeout(..., 10s)` para evitar travas (services de Inventory/Assets/Locations).
   * Cache: `DashboardService.getSummary()` usa cache de 60s em `localStorage` e atualiza em segundo plano.
   * Erros: páginas exibem mensagens claras e ação de retry (Dashboard). Toasts informam indisponibilidade temporária.

4. Testes A/B
   * Infra simples com `src/lib/ab.ts` armazenando eventos em `localStorage` (experimento `landing-cta`).
   * Integração no `LandingPage` e painel de visualização em Admin Tools.

5. Consistência Visual
   * Padronização de estados ativos e foco na navegação; melhorias de feedback em botões e modais.
