# **4\. Async Tasks & Background Workers**

**Estratégia:** Substituir Workers persistentes (que custam $7/mês no Render) por execução baseada em eventos e CRON externo.

## **1\. Arquitetura de "Poor Man's Worker"**

### **1.1. Tarefas Rápidas (Inline)**

Tarefas \< 2 segundos (ex: atualizar saldo, logar auditoria) rodam na própria thread da Request HTTP ou em uma Thread Python (threading.Thread) "fire-and-forget".

* *Risco:* Se o container morrer, a task morre. Aceitável para logs, inaceitável para pagamentos.

### **1.2. Tarefas Agendadas (Cron Jobs Externos)**

Usaremos o **GitHub Actions** como agendador. Ele roda o container ubuntu, faz um curl para um endpoint seguro do Django, e o Django executa a lógica.

## **2\. Implementação do GitHub Actions Cron**

Arquivo: .github/workflows/daily\_checks.yml

name: System Cron Jobs  
on:  
  schedule:  
    \# 10:00 UTC \= 07:00 Brasil  
    \- cron: '0 10 \* \* 1-5'   
jobs:  
  trigger-api:  
    runs-on: ubuntu-latest  
    steps:  
      \- name: Wake up & Trigger Low Stock Email  
        run: |  
          \# Primeiro request para garantir wake-up (timeout longo)  
          curl \-X GET \[https://davus-backend.onrender.com/health/\](https://davus-backend.onrender.com/health/) \--max-time 100  
            
          \# Segundo request dispara a tarefa real  
          curl \-X POST \[https://davus-backend.onrender.com/api/v1/jobs/check-stock/\](https://davus-backend.onrender.com/api/v1/jobs/check-stock/) \\  
          \-H "Authorization: Api-Key ${{ secrets.CRON\_API\_KEY }}" \\  
          \-H "Content-Type: application/json"

## **3\. Endpoints de Jobs (Backend)**

Criar app jobs no Django apenas para isso.

\# jobs/views.py  
@api\_view(\['POST'\])  
def trigger\_daily\_check(request):  
    key \= request.headers.get('Authorization')  
    if key \!= settings.CRON\_API\_KEY:  
        return Response(status=403)  
      
    \# Executa lógica síncrona (pois o GitHub Actions espera até 6h)  
    count \= check\_low\_stock\_and\_send\_email()   
    return Response({"status": "success", "emails\_sent": count})

## **4\. E-mails Transacionais**

* **Serviço:** SendGrid (Free Tier) ou Gmail SMTP.  
* **Configuração Django:**  
  EMAIL\_BACKEND \= 'django.core.mail.backends.smtp.EmailBackend'  
  EMAIL\_HOST \= 'smtp.sendgrid.net'  
  EMAIL\_PORT \= 587  
  EMAIL\_USE\_TLS \= True  
